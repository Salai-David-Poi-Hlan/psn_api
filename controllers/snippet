import json
import logging
import xml.etree.ElementTree as ET
from crypt import methods
from datetime import datetime
from odoo import http, fields, _
from odoo.addons.psn_api.models.common import invalid_response, valid_response
from odoo.http import request
import xmltodict


_logger = logging.getLogger(__name__)


class PsnAPI(http.Controller):

    def get_token(self, api_key):
        """Authenticate and get access token"""
        try:
            user_id = request.env["res.users.apikeys"]._check_credentials(scope="rpc", key=api_key)
            if user_id:
                access_token = request.env["api.access_token"].find_or_create_token(user_id=user_id, create=True)
                return access_token
        except Exception as e:
            _logger.error("Authentication error: %s", e)
        return None

    def extract_api_key_from_soap(self, xml_data):
        """Extract API key from SOAP header"""
        try:
            ns = {
                "wsse": "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd",
                "soapenv": "http://schemas.xmlsoap.org/soap/envelope/"
            }
            root = ET.fromstring(xml_data)
            password_el = root.find(".//wsse:Password", ns)
            if password_el is not None:
                return password_el.text.strip()
        except Exception as e:
            _logger.error("Failed to parse SOAP XML: %s", e)
        return None

    def parse_hotel_reservation_complete(self, xml_data):
        """Ultra simple XML to dict conversion"""
        try:
            # Convert entire XML to dictionary
            xml_dict = xmltodict.parse(xml_data)

            # Log for debugging (optional)
            _logger.info("Full XML converted to dict: %s", json.dumps(xml_dict, indent=2, default=str)[:2000])

            # Return the full dictionary - let create_reservation_from_xml handle the navigation
            return xml_dict

        except Exception as e:
            _logger.error("Failed to parse XML: %s", e)
            return {}

    def create_reservation_from_xml(self, xml_dict):
        """
        Create hotel reservation from XML dictionary - Fixed for your XML format
        """
        try:
            # Get required models
            HotelReservation = request.env['hotel.reservation']
            HotelRoomType = request.env['hotel.room.type']
            HotelRoom = request.env['hotel.room']

            # Navigate the XML structure (corrected paths based on your XML)
            soap_envelope = xml_dict.get('soap-env:Envelope', {})
            soap_body = soap_envelope.get('soap-env:Body', {})

            # Your XML has NO namespace prefix for OTA elements
            ota_request = soap_body.get('OTA_HotelResNotifRQ', {})

            if not ota_request:
                _logger.error("No OTA_HotelResNotifRQ found in XML")
                return {'success': False, 'error': 'No OTA request found in XML'}

            # Get hotel reservations (no namespace prefix)
            hotel_reservations_container = ota_request.get('HotelReservations', {})
            hotel_reservations = hotel_reservations_container.get('HotelReservation', [])

            # Ensure it's a list
            if not isinstance(hotel_reservations, list):
                hotel_reservations = [hotel_reservations]

            if not hotel_reservations:
                _logger.error("No hotel reservations found")
                return {'success': False, 'error': 'No hotel reservations found in XML'}

            # Process the first reservation
            hotel_res = hotel_reservations[0]
            _logger.info("Processing hotel reservation...")

            # STEP 1: Generate custom reservation number
            all_reservations = HotelReservation.sudo().search([
                ('reservation_no', 'like', 'R/')
            ])

            highest_number = 0
            for reservation in all_reservations:
                try:
                    if '/' in reservation.reservation_no:
                        number_str = reservation.reservation_no.split('/')[-1]
                        number = int(number_str)
                        if number > highest_number:
                            highest_number = number
                except:
                    continue

            next_number = highest_number + 1
            new_reservation_no = f"R/{next_number:05d}"
            _logger.info(f"Generated reservation number: {new_reservation_no}")

            # STEP 2: Extract customer info (no namespace prefixes)
            res_global_info = hotel_res.get('ResGlobalInfo', {})
            profiles_container = res_global_info.get('Profiles', {})

            # Based on your XML, it's ProfileInfo -> Profile -> Customer
            profile_info = profiles_container.get('ProfileInfo', {})
            profile = profile_info.get('Profile', {})
            customer = profile.get('Customer', {})

            person_name = customer.get('PersonName', {})
            first_name = person_name.get('GivenName', '')
            last_name = person_name.get('Surname', '')
            customer_name = f"{first_name} {last_name}".strip()

            # Extract contact info
            telephone = customer.get('Telephone', {})
            phone = telephone.get('@PhoneNumber', '') if isinstance(telephone, dict) else ''

            email = customer.get('Email', '')
            # Handle email if it's a dict with #text
            if isinstance(email, dict):
                email = email.get('#text', '')

            _logger.info(f"Customer: {customer_name}, Email: {email}, Phone: {phone}")

            # STEP 3: Extract room stays and dates (no namespace prefixes)
            room_stays_container = hotel_res.get('RoomStays', {})
            room_stays = room_stays_container.get('RoomStay', [])

            if not isinstance(room_stays, list):
                room_stays = [room_stays]

            checkin_date = checkout_date = ''
            adults = children = 0
            room_types = []

            if room_stays:
                first_room_stay = room_stays[0]

                # Extract dates from TimeSpan
                time_span = first_room_stay.get('TimeSpan', {})
                checkin_date = time_span.get('@Start', '')
                checkout_date = time_span.get('@End', '')

                _logger.info(f"Check-in: {checkin_date}, Check-out: {checkout_date}")

                # Extract guest counts
                guest_counts_container = first_room_stay.get('GuestCounts', {})
                guest_counts = guest_counts_container.get('GuestCount', [])

                if not isinstance(guest_counts, list):
                    guest_counts = [guest_counts]

                for guest_count in guest_counts:
                    age_code = guest_count.get('@AgeQualifyingCode', '')
                    count = int(guest_count.get('@Count', 1))

                    if age_code in ['10', '1']:  # Adults
                        adults += count
                    elif age_code in ['8', '7', '2']:  # Children
                        children += count
                    else:
                        adults += count  # Default to adults

                # Ensure at least 1 adult
                if adults == 0:
                    adults = 1

                _logger.info(f"Adults: {adults}, Children: {children}")

                # Extract room types
                room_types_container = first_room_stay.get('RoomTypes', {})
                room_types_data = room_types_container.get('RoomType', [])

                if not isinstance(room_types_data, list):
                    room_types_data = [room_types_data]

                room_types = []
                for rt in room_types_data:
                    room_type_info = {
                        'room_type_code': rt.get('@RoomTypeCode', ''),
                        'room_type': rt.get('@RoomType', ''),
                        'room_id': rt.get('@RoomID', '')
                    }

                    # Extract room description
                    room_desc_container = rt.get('RoomDescription', {})
                    room_desc_text = room_desc_container.get('Text', '')
                    if isinstance(room_desc_text, dict):
                        room_type_info['description'] = room_desc_text.get('#text', '')
                    else:
                        room_type_info['description'] = room_desc_text

                    room_types.append(room_type_info)

                _logger.info(f"Room types: {room_types}")

            # STEP 4: Parse and format dates
            def parse_and_format_datetime(date_string, default_time):
                """Parse date string and convert to proper datetime format for Odoo"""
                try:
                    if not date_string:
                        return None

                    date_string = date_string.strip()

                    # Handle different date formats
                    parts = date_string.replace('/', '-').split('-')
                    if len(parts) == 3:
                        year, month, day = parts
                        month = month.zfill(2)
                        day = day.zfill(2)
                        normalized_date = f"{year}-{month}-{day}"
                    else:
                        normalized_date = date_string

                    parsed_date = datetime.strptime(normalized_date, '%Y-%m-%d')
                    datetime_str = f"{normalized_date} {default_time}"
                    final_datetime = datetime.strptime(datetime_str, '%Y-%m-%d %H:%M:%S')

                    return final_datetime

                except ValueError as e:
                    _logger.error(f"Error parsing date '{date_string}': {e}")
                    return None

            checkin_datetime_obj = parse_and_format_datetime(checkin_date, "14:00:00")
            checkout_datetime_obj = parse_and_format_datetime(checkout_date, "12:00:00")

            # Current datetime for date_order
            date_order = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

            # STEP 5: Extract comments (if any)
            customer_note = 'Reservation from Siteminder XML'

            # STEP 6: Create reservation lines based on room types from XML
            reservation_lines = []

            for room_type_data in room_types:
                room_type_code = room_type_data.get('room_type_code', '')
                room_type_name = room_type_data.get('room_type', '')

                _logger.info(f"Processing room: {room_type_code} - {room_type_name}")

                # Find room type by name
                room_type_odoo = HotelRoomType.sudo().search([
                    ('name', '=', room_type_name)
                ], limit=1)

                # Find room by room type code
                room_odoo = HotelRoom.sudo().search([
                    ('name', '=', room_type_code)
                ], limit=1)

                if room_odoo and room_type_odoo:
                    reservation_lines.append((0, 0, {
                        'categ_id': room_type_odoo.id,
                        'reserve': [(6, 0, [room_odoo.id])],
                    }))
                    _logger.info(f"Added reservation line: {room_odoo.name}")
                else:
                    _logger.warning(f"Could not find room type '{room_type_name}' or room '{room_type_code}' in Odoo")

            # STEP 7: Create reservation
            reservation_vals = {
                'date_order': date_order,
                'company_id': 1,
                'partner_id': 149,
                'customer_name': customer_name,
                'customer_note': customer_note,
                'reservation_referent': 'other',
                'pricelist_id': 1,
                'partner_invoice_id': 149,
                'partner_order_id': 149,
                'partner_shipping_id': 149,
                'checkin': fields.Datetime.from_string(checkin_datetime_obj) if checkin_datetime_obj else None,
                'checkout': fields.Datetime.from_string(checkout_datetime_obj) if checkout_datetime_obj else None,
                'adults': adults,
                'children': children,
                'state': 'draft',
                'payment': 'not_paid',
                'email': email,
                'ph_no': phone,
                'reservation_line': reservation_lines
            }

            # Create the reservation
            new_reservation = HotelReservation.sudo().create(reservation_vals)
            _logger.info(f"Created reservation with ID: {new_reservation.id}")

            # Update with custom reservation number
            new_reservation.sudo().write({
                'reservation_no': new_reservation_no
            })

            # Refresh the record
            new_reservation.sudo().invalidate_cache()
            updated_reservation = HotelReservation.sudo().browse(new_reservation.id)

            _logger.info(f"Reservation created successfully: {updated_reservation.reservation_no}")

            return {
                'success': True,
                'reservation_id': updated_reservation.id,
                'reservation_no': updated_reservation.reservation_no,
                'customer_name': customer_name,
                'checkin': checkin_date,
                'checkout': checkout_date,
                'adults': adults,
                'children': children,
                'email': email,
                'phone': phone,
                'message': 'Reservation created successfully'
            }

        except Exception as e:
            _logger.error(f"Error creating reservation: {str(e)}")
            import traceback
            _logger.error(f"Full traceback: {traceback.format_exc()}")
            return {
                'success': False,
                'error': f'Error: {str(e)}'
            }






    @http.route(["/api/test_connection"], methods=["POST"], type="http", auth="none", csrf=False)
    def get_test_connection(self, **post):
        """Main API endpoint for Siteminder reservations"""
        _logger.info("===== Siteminder API Call Received =====")

        try:
            soap_body = request.httprequest.data.decode("utf-8")
            _logger.info(f"Received XML: {soap_body[:500]}...")

            # Extract and validate API key
            api_key = self.extract_api_key_from_soap(soap_body)
            if not api_key:
                return invalid_response(
                    "Authentication Error",
                    "Missing <wsse:Password> field in SOAP XML.",
                    403,
                )

            # Validate access token
            access_token = self.get_token(api_key)
            if not access_token:
                return invalid_response(
                    "Authentication Error",
                    "Invalid API key.",
                    401,
                )

            _logger.info("Authentication successful - Creating manual reservation...")

            parse_data=self.parse_hotel_reservation_complete(soap_body)
            reservation_result = self.create_reservation_from_xml(parse_data)
            if reservation_result['success']:
                _logger.info(f"✅ Manual reservation created successfully: {reservation_result['reservation_no']}")

                # Return success response with reservation details
                response_data = {
                    "status": "success",
                    "message": "Manual reservation created successfully",
                    "reservation_data": reservation_result,
                    "timestamp": fields.Datetime.now().isoformat(),
                    "Real Soap Body":parse_data
                }

                return request.make_response(
                    json.dumps(response_data, indent=2, default=str),
                    headers=[
                        ('Content-Type', 'application/json'),
                        ('Access-Control-Allow-Origin', '*')
                    ]
                )
            else:
                _logger.error(f"❌ Failed to create manual reservation: {reservation_result['error']}")

                # Return error response
                error_response = {
                    "status": "error",
                    "message": "Failed to create manual reservation",
                    "error": reservation_result['error'],
                    "timestamp": fields.Datetime.now().isoformat()
                }

                return request.make_response(
                    json.dumps(error_response, indent=2, default=str),
                    status=500,
                    headers=[
                        ('Content-Type', 'application/json'),
                        ('Access-Control-Allow-Origin', '*')
                    ]
                )

        except Exception as e:
            _logger.error(f"Exception in test_connection endpoint: {str(e)}")

            error_response = {
                "status": "error",
                "message": "Internal server error",
                "error": str(e),
                "timestamp": fields.Datetime.now().isoformat()
            }

            return request.make_response(
                json.dumps(error_response, indent=2, default=str),
                status=500,
                headers=[
                    ('Content-Type', 'application/json'),
                    ('Access-Control-Allow-Origin', '*')
                ]
            )
